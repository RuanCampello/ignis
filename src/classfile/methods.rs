use crate::classfile::{ClassfileError, ConstantPool, attributes::Attribute, get_attributes, read};
use bitflags::bitflags;
use bumpalo::{Bump, collections::Vec};
use std::io::{BufReader, Read};

/// `method_info` as defined by JVSM 4.6.
#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub(in crate::classfile) struct Method<'m> {
    access_flags: MethodFlags,
    name_index: u16,
    descriptor_index: u16,
    attributes_count: u16,
    attributes: &'m [Attribute<'m>],
}

bitflags! {
    /// Method access and proprieties flags.
    #[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
    pub struct MethodFlags: u16 {
        /// Declared public; may be accessed from outside its package.
        const PUBLIC = 0x0001;
        /// Declared private; accessible only within the defining class and other classes belonging to the same nest.
        const PRIVATE = 0x0002;
        /// Declared protected; may be accessed within subclasses.
        const PROTECTED = 0x0004;
        /// Declared static.
        const STATIC = 0x0008;
        /// Declared final; must not be overridden.
        const FINAL = 0x0010;
        /// Declared synchronized; invocation is wrapped by a monitor use.
        const SYNCHRONIZED = 0x0020;
        /// A bridge method, generated by the compiler.
        const BRIDGE = 0x0040;
        /// Declared with variable number of arguments.
        const VARARGS = 0x0080;
        /// Declared native; implemented in a language other than the Java programming language.
        const NATIVE = 0x0100;
        /// Declared abstract; no implementation is provided.
        const ABSTRACT = 0x0400;
        /// In a class file whose major version number is at least 46 and at most 60: Declared strictfp.
        const STRICT = 0x0800;
        /// Declared synthetic; not present in the source code.
        const SYNTHETIC = 0x1000;
    }
}

pub(in crate::classfile) fn parse_methods<'m, 'pool>(
    reader: &mut BufReader<impl Read>,
    constant_pool: &'pool ConstantPool<'pool>,
    arena: &'m Bump,
) -> Result<&'m [Method<'m>], ClassfileError> {
    let methods_count = read::<u16>(reader)? as usize;
    let mut methods = Vec::with_capacity_in(methods_count, arena);

    for _ in (0..methods_count) {
        let entry = Method {
            access_flags: MethodFlags::from_bits_truncate(read(reader)?),
            name_index: read(reader)?,
            descriptor_index: read(reader)?,
            attributes_count: read(reader)?,
            attributes: get_attributes(reader, constant_pool, arena)?,
        };

        methods.push(entry)
    }

    Ok(methods.into_bump_slice())
}
